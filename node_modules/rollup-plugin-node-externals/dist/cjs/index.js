'use strict';

const module$1 = require('module');
const path = require('path');
const fs = require('fs');
const process$1 = require('process');

/*
How it works:
`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.
*/

class Node {
	value;
	next;

	constructor(value) {
		this.value = value;
	}
}

class Queue {
	#head;
	#tail;
	#size;

	constructor() {
		this.clear();
	}

	enqueue(value) {
		const node = new Node(value);

		if (this.#head) {
			this.#tail.next = node;
			this.#tail = node;
		} else {
			this.#head = node;
			this.#tail = node;
		}

		this.#size++;
	}

	dequeue() {
		const current = this.#head;
		if (!current) {
			return;
		}

		this.#head = this.#head.next;
		this.#size--;
		return current.value;
	}

	clear() {
		this.#head = undefined;
		this.#tail = undefined;
		this.#size = 0;
	}

	get size() {
		return this.#size;
	}

	* [Symbol.iterator]() {
		let current = this.#head;

		while (current) {
			yield current.value;
			current = current.next;
		}
	}
}

function pLimit(concurrency) {
	if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}

	const queue = new Queue();
	let activeCount = 0;

	const next = () => {
		activeCount--;

		if (queue.size > 0) {
			queue.dequeue()();
		}
	};

	const run = async (fn, resolve, args) => {
		activeCount++;

		const result = (async () => fn(...args))();

		resolve(result);

		try {
			await result;
		} catch {}

		next();
	};

	const enqueue = (fn, resolve, args) => {
		queue.enqueue(run.bind(undefined, fn, resolve, args));

		(async () => {
			// This function needs to wait until the next microtask before comparing
			// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
			// when the run function is dequeued and called. The comparison in the if-statement
			// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
			await Promise.resolve();

			if (activeCount < concurrency && queue.size > 0) {
				queue.dequeue()();
			}
		})();
	};

	const generator = (fn, ...args) => new Promise(resolve => {
		enqueue(fn, resolve, args);
	});

	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount,
		},
		pendingCount: {
			get: () => queue.size,
		},
		clearQueue: {
			value: () => {
				queue.clear();
			},
		},
	});

	return generator;
}

class EndError extends Error {
	constructor(value) {
		super();
		this.value = value;
	}
}

// The input can also be a promise, so we await it.
const testElement = async (element, tester) => tester(await element);

// The input can also be a promise, so we `Promise.all()` them both.
const finder = async element => {
	const values = await Promise.all(element);
	if (values[1] === true) {
		throw new EndError(values[0]);
	}

	return false;
};

async function pLocate(
	iterable,
	tester,
	{
		concurrency = Number.POSITIVE_INFINITY,
		preserveOrder = true,
	} = {},
) {
	const limit = pLimit(concurrency);

	// Start all the promises concurrently with optional limit.
	const items = [...iterable].map(element => [element, limit(testElement, element, tester)]);

	// Check the promises either serially or concurrently.
	const checkLimit = pLimit(preserveOrder ? 1 : Number.POSITIVE_INFINITY);

	try {
		await Promise.all(items.map(element => checkLimit(finder, element)));
	} catch (error) {
		if (error instanceof EndError) {
			return error.value;
		}

		throw error;
	}
}

const typeMappings = {
	directory: 'isDirectory',
	file: 'isFile',
};

function checkType(type) {
	if (type in typeMappings) {
		return;
	}

	throw new Error(`Invalid type specified: ${type}`);
}

const matchType = (type, stat) => type === undefined || stat[typeMappings[type]]();

async function locatePath(
	paths,
	{
		cwd = process$1.cwd(),
		type = 'file',
		allowSymlinks = true,
		concurrency,
		preserveOrder,
	} = {},
) {
	checkType(type);

	const statFunction = allowSymlinks ? fs.promises.stat : fs.promises.lstat;

	return pLocate(paths, async path_ => {
		try {
			const stat = await statFunction(path.resolve(cwd, path_));
			return matchType(type, stat);
		} catch {
			return false;
		}
	}, {concurrency, preserveOrder});
}

const findUpStop = Symbol('findUpStop');

async function findUpMultiple(name, options = {}) {
	let directory = path.resolve(options.cwd || '');
	const {root} = path.parse(directory);
	const stopAt = path.resolve(directory, options.stopAt || root);
	const limit = options.limit || Number.POSITIVE_INFINITY;
	const paths = [name].flat();

	const runMatcher = async locateOptions => {
		if (typeof name !== 'function') {
			return locatePath(paths, locateOptions);
		}

		const foundPath = await name(locateOptions.cwd);
		if (typeof foundPath === 'string') {
			return locatePath([foundPath], locateOptions);
		}

		return foundPath;
	};

	const matches = [];
	// eslint-disable-next-line no-constant-condition
	while (true) {
		// eslint-disable-next-line no-await-in-loop
		const foundPath = await runMatcher({...options, cwd: directory});

		if (foundPath === findUpStop) {
			break;
		}

		if (foundPath) {
			matches.push(path.resolve(directory, foundPath));
		}

		if (directory === stopAt || matches.length >= limit) {
			break;
		}

		directory = path.dirname(directory);
	}

	return matches;
}

async function findUp(name, options = {}) {
	const matches = await findUpMultiple(name, {...options, limit: 1});
	return matches[0];
}

/**
 * Determines if the `child` path is under the `parent` path.
 */
function isInDirectory(parent, child) {
    const relativePath = path.relative(parent, child);
    return !relativePath.startsWith('..') && !path.isAbsolute(relativePath);
}
/**
 * Iterates over package.json file paths recursively found in parent directories, starting from the
 * current working directory. If the current working directory is in a git repository, then package.json
 * files outside of the git repository will not be yielded.
 * @internal
 */
async function* findPackagePaths() {
    // Find git root if in git repository
    const gitDirectoryPath = await findUp('.git', { type: 'directory' });
    const gitRootPath = gitDirectoryPath === undefined
        ? undefined
        : path.dirname(gitDirectoryPath);
    function isInGitDirectory(path) {
        return gitRootPath === undefined || isInDirectory(gitRootPath, path);
    }
    let cwd = process.cwd();
    let packagePath;
    while ((packagePath = await findUp('package.json', { type: 'file', cwd })) &&
        isInGitDirectory(packagePath)) {
        yield packagePath;
        cwd = path.dirname(path.dirname(packagePath));
    }
}
/** @internal */
async function findDependencies({ packagePaths, keys, warnings }) {
    const dependencies = new Set();
    for await (const packagePath of packagePaths) {
        try {
            const pkg = JSON.parse((await fs.promises.readFile(packagePath)).toString()) ?? {};
            for (const key of keys) {
                const dependenciesToVersions = pkg[key] ?? {};
                for (const dependency of Object.keys(dependenciesToVersions)) {
                    dependencies.add(dependency);
                }
            }
        }
        catch {
            warnings.push(`Couldn't process '${packagePath}'. Make sure it is a valid JSON or use the 'packagePath' option`);
        }
    }
    return Array.from(dependencies);
}

/**
 * A Rollup plugin that automatically declares NodeJS built-in modules
 * and optionally npm dependencies as 'external'.
 *
 * Useful when you don't want to bundle node/npm modules with your own code
 * but rather import or require them at runtime.
 */
function externals(options = {}) {
    // Consolidate options
    const config = {
        packagePath: [],
        builtins: true,
        prefixedBuiltins: 'strip',
        deps: false,
        devDeps: true,
        peerDeps: true,
        optDeps: true,
        include: [],
        exclude: [],
        ...options
    };
    // This will store all eventual warnings until we can display them
    const warnings = [];
    // Map the include and exclude options to arrays of regexes
    const [include, exclude] = ['include', 'exclude'].map(optionName => []
        .concat(config[optionName])
        .map((entry, index) => {
        if (entry instanceof RegExp) {
            return entry;
        }
        else if (typeof entry === 'string') {
            return new RegExp('^' + entry.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$');
        }
        else {
            if (entry) {
                warnings.push(`Ignoring wrong entry type #${index} in '${optionName}' option: '${entry}'`);
            }
            return /(?=no)match/;
        }
    }));
    // Filter function to keep only non excluded dependencies
    const isNotExcluded = (id) => !exclude.some(rx => rx.test(id));
    // Array of the final regexes
    const externals = [];
    const isExternal = (id) => externals.some(rx => rx.test(id));
    return {
        name: 'node-externals',
        async buildStart() {
            // 1) Filter NodeJS builtins, supporting potential import from a sub directory (e.g. 'fs/promises')
            const builtins = (config.builtins ? module$1.builtinModules : []).filter(isNotExcluded);
            if (builtins.length > 0) {
                externals.push(new RegExp('^(?:' + builtins.join('|') + ')(?:/.+)?$'));
            }
            // 2) Find and filter dependencies, supporting potential import from a sub directory (e.g. 'lodash/map')
            const packagePaths = [].concat(config.packagePath);
            const dependencies = (await findDependencies({
                packagePaths: packagePaths.length > 0 ? packagePaths : findPackagePaths(),
                keys: [
                    config.deps && 'dependencies',
                    config.devDeps && 'devDependencies',
                    config.peerDeps && 'peerDependencies',
                    config.optDeps && 'optionalDependencies'
                ].filter(Boolean),
                warnings
            })).filter(isNotExcluded);
            if (dependencies.length > 0) {
                externals.push(new RegExp('^(?:' + dependencies.join('|') + ')(?:/.+)?$'));
            }
            // 3) Add the include option
            if (include.length > 0) {
                externals.push(...include);
            }
            // All done. Issue the warnings we may have collected
            let msg;
            while (msg = warnings.shift()) { // eslint-disable-line no-cond-assign
                this.warn(msg);
            }
        },
        resolveId(importee, importer, { isEntry }) {
            // Ignore entry chunks & don't mess with other plugins
            if (isEntry || !importee.charCodeAt(0) || !importer?.charCodeAt(0)) {
                return null;
            }
            // Remove node: prefix so builtins resolve to their unprefixed equivalent
            let stripped = importee;
            if (config.prefixedBuiltins) {
                if (stripped.startsWith('node:')) {
                    stripped = stripped.slice(5);
                }
                else if (stripped.startsWith('nodejs:')) {
                    stripped = stripped.slice(7);
                }
            }
            // Return object if importee should be treated as an external module,
            // otherwise return `null` to let Rollup and other plugins handle it
            return isExternal(stripped) && isNotExcluded(stripped)
                ? { id: config.prefixedBuiltins === 'strip' ? stripped : importee, external: true }
                : null;
        }
    };
}

module.exports = externals;
